---
layout: post
title:  Day 016
ref: day-016
lang: en
date:   2016-04-29 00:00:00 +0800
course_id: 2
---

![](/images/placeholder.png)

The goals are,

- Be able to use the How to design data definitions (HtDD) recips to design data definitions for atomic data
- Be able to identify problem domin information that should be represented as simple atomic data, intervlas, enumerations, itemizations and mixed data itemizations
- Be able to use the data driven templates recipe to generate templates for functions operating on atomic data
- Be able to use the How to design function (HtDF) recipe to design functions operating on atomic data

> Data design is a cretial part of program design.

Systems tend to have more function design than data design, but the data design drive the design of the function.


Introducing `cond`, it is a multi-armed conditional. It can have any number of cases all at the same level, kind like `if-else` statement in other programming languages.

To form `cond` expression,

```lisp
(cond [<expression_question> <expression_answer>]
      ...) ;; One more more question answer pairs
```

For each question must evaluate to a boolean and the last question can be `else`.

Code snippets below are equivalent,

```lisp
(define (aspect-ratio img)
  (if (> (image-height image) (image-width image))
      "tall"
	  (if (= (image-height image) (image-width image))
	      "square"
		  "wide")))
```

```lisp
;; (define (function_name parameter)
;;   (cond [Q A]
;;         [Q A]
;; 		   [Q A]))

(define (aspect-ratio img)
  (cond [(> (image-height image) (image-width image)) "tall"]
        [(= (image-height image) (image-width image)) "square"]
		[else "wide"]))
```

In BSL, `()` and `[]` are both equivalent, but by convention we use `[]` around question/answer pairs in `cond` which make `cond` easier to read.

The special case called `else`, if non of the previous questions were true, do this.

To evaluate a `cond` expression,

1. If there are no question/answer pairs. singal an error
1. If the first question is not a value, evalute it and replace it with its value. Replace the entire cond with a new `cond` in which the first question has been replaced by its value
1. If the first question is true/else, replace the entire `cond` expression with the first answer
1. If the first question is false drop the first question/answer pair, Replace the `cond` with a new `cond` that does not have the first question/answer pair
1. Since the first question is not, true/false, signal an error
