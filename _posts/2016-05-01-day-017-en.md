---
layout: post
title:  Day 017
ref: day-017
lang: en
date:   2016-05-01 00:00:00 +0800
course_id: 0
---

![](/images/Day017-en.png)

# Computational Thinking

**What do computer scientists do?**

- They think computationally (Abstractions, algorithms, automated execution)
- Computational thinking will be a fundamental skill used by everyone in the world
- Just like the 3 Rs (Reading, Riting, Rithmetic) Ubiquitous computing and computers will enable the spread of computational thinking as a fundamental skill

**Computational Thinking Process**

- Identify/invent useful abstractions (Suppressing details, formulating interfaces)
- Formulate solution to a problem as a computational experiment using abstractions
- Design and construct a sufficiently efficient implementation of experiment
- Validate experimental setup (Debug)
- Run experiment
- Evaluate results of experiment
- Repeat as needed (Repeat the steps above)

**Three A of Computational Thinking**

- **Abstraction**
  - Choosing the right abstractions
  - Operating in terms of multiple layers of abstraction simultaneously
  - Defining the relationships the between layers
- **Automation**
  - Think in terms of mechanizing abstractions
  - Mechanizations is possible (Precise and exacting notations and models)
- **Algorithms**
  - Language for describing automated processes
  - Allows abstraction of details

**Example of Computational Thinking**

- How **difficult/complexity** is this problem and how best can developer solve it? (Theoretical computer science gives precise meaning to these and related question and answer)
- Thinking **recursively** (Reformulating a seemingly difficult problem into one which we know how to solve; Reduction, embedding, transformation, simulation)

# Where Have We Been

We have learned four major topics and a language,

- Learning a language for expressing computations (Python)
- Learning about the process and writing and debugging a program (By Systematic)
- Learning to estimate computational (Computational Complexity)
- Learning about the process of moving from a problem statement to a computational formulation of a method for solving the problem (Use Abstraction)
- Learning a basic set of recipes (Algorithms)

**Why Python?**

- Easy to learn and use (Simple syntax, interpretive, do not have to worry about managing memory)
- Modern (Object-oriented)
- Increasingly popular

**Writing, Testing, and Debugging Program**

Take it a step at time,

- Understand problem
- Think about overall structure and algorithms independently of expression in programming language
- Break into small parts
- Identify useful abstractions (data and functional)
- Code and unit test a part at a time
- First functionality, then efficiency
- Start with pseudo code

Be systematic,

- When debugging, think scientific method
- Ask yourself why program did what it did, not why it did not do what you wanted it to do

**Estimating Complexity**

- Big O Notation (Orders of growth; Exponential, Polynomial, Linear, Log, Constant)
- Recognizing common patterns of computation
- Learning to map problems into templates of solutions (Bisection search; Tree search)
- Some problems inherently expensive to solve

**From Problem Statement To Computation**

- Break the problem into a series of smaller problems
- Try and related problem to a problem you/somebody else have already solved (E.g. Viewed as a knapsack problem)
- Think about what kind of output you might like to see
- Think about how to approximate solutions (Solve a simpler problem; Find a series of solutions that approaches a perfect answer)

**Algorithms**

Kinds of Algorithms,

- exhaustive enumeration,
- guess and check,
- successive approximation,
- greedy algorithms,
- divide and conquer,
- decision trees

Specific Algorithms,

- Binary search,
- Merge sort,
- Deep first search
- Breadth first search

# What's Next?

- Second part of 6.00 course
- Introductory algorithms and data structures courses
- Introduction to artificial intelligence
- Software engineering
- Computer architecture
